Okay, I will implement Step 13: Word Document Generation.

This involves setting up the DOCX generation logic using the `docx` library, creating a placeholder for the ABNT template, configuring an S3 client for document storage, implementing S3 upload and presigned URL generation functions, and creating a tRPC router to expose the document export functionality.

Here's what I did and why: This file initializes the AWS S3 client. It reads AWS credentials and region from environment variables. This client will be used for interacting with S3, such as uploading generated documents and creating presigned URLs.
Filepath: src/lib/s3/client.ts
```ts
/**
 * AWS S3 Client Configuration
 *
 * This module configures and exports a singleton instance of the AWS S3 client.
 * It handles API key management and provides a configured client for S3 interactions.
 */
import { S3Client } from "@aws-sdk/client-s3";

let s3ClientInstance: S3Client | null = null;

const AWS_REGION = process.env.AWS_REGION || "us-east-1"; // Default region if not set
const AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID;
const AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY;

/**
 * Retrieves the singleton S3 client instance.
 * Throws an error if AWS credentials are not configured (except in test environment).
 * @returns The configured S3 client.
 * @throws {Error} If AWS credentials are missing in non-test environments.
 */
export function getS3Client(): S3Client {
  if (s3ClientInstance) {
    return s3ClientInstance;
  }

  if (
    !AWS_ACCESS_KEY_ID ||
    !AWS_SECRET_ACCESS_KEY
  ) {
    if (process.env.NODE_ENV !== "test") {
      console.error(
        "AWS S3 credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY) are not configured.",
      );
      throw new Error(
        "AWS S3 credentials are missing. Configure environment variables.",
      );
    }
    // For test environment, allow missing credentials if calls are mocked
    console.warn("AWS S3 credentials not found, assuming mocked S3 client for tests.");
  }

  try {
    s3ClientInstance = new S3Client({
      region: AWS_REGION,
      credentials: {
        accessKeyId: AWS_ACCESS_KEY_ID || "test_access_key", // Dummy for tests if not set
        secretAccessKey: AWS_SECRET_ACCESS_KEY || "test_secret_key", // Dummy for tests if not set
      },
    });
    return s3ClientInstance;
  } catch (error) {
    console.error("Failed to initialize S3 client:", error);
    if (error instanceof Error) {
      throw new Error(`Failed to initialize S3 client: ${error.message}`);
    }
    throw new Error("An unknown error occurred while initializing S3 client.");
  }
}
```
Here's what I did and why: This file contains actions for interacting with S3, specifically uploading files and generating presigned URLs for downloads. `uploadToS3` uploads a buffer to a specified S3 path. `getPresignedUrlForDownload` generates a temporary URL that clients can use to download the file directly from S3. This abstracts S3 operations for use in the export router.
Filepath: src/lib/s3/actions.ts
```ts
/**
 * S3 Actions
 *
 * This module provides functions for common S3 operations like
 * uploading files and generating presigned URLs.
 */
import {
  PutObjectCommand,
  GetObjectCommand,
  S3ServiceException,
} from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";
import { getS3Client } from "./client";

const S3_BUCKET_NAME = process.env.S3_BUCKET_NAME;
const PRESIGNED_URL_EXPIRES_IN = 3600; // 1 hour in seconds

/**
 * Uploads a file buffer to S3.
 * @param key - The S3 object key (path within the bucket).
 * @param body - The file content as a Buffer.
 * @param contentType - The MIME type of the file.
 * @returns The S3 PutObjectCommandOutput on success.
 * @throws {Error} If S3_BUCKET_NAME is not configured or if the upload fails.
 */
export async function uploadToS3(
  key: string,
  body: Buffer,
  contentType: string,
) {
  if (!S3_BUCKET_NAME) {
    throw new Error(
      "S3_BUCKET_NAME is not configured in environment variables.",
    );
  }
  const s3Client = getS3Client();
  const command = new PutObjectCommand({
    Bucket: S3_BUCKET_NAME,
    Key: key,
    Body: body,
    ContentType: contentType,
  });

  try {
    const response = await s3Client.send(command);
    console.log(`Successfully uploaded ${key} to ${S3_BUCKET_NAME}.`);
    return response;
  } catch (error) {
    console.error(`Error uploading ${key} to S3:`, error);
    if (error instanceof S3ServiceException) {
      throw new Error(
        `S3 Upload Error (${error.name}): ${error.message} - Code: ${error.$metadata.httpStatusCode}`,
      );
    }
    throw new Error(
      `An unexpected error occurred during S3 upload: ${(error as Error).message}`,
    );
  }
}

/**
 * Generates a presigned URL for downloading an object from S3.
 * @param key - The S3 object key.
 * @returns A promise resolving to the presigned URL string.
 * @throws {Error} If S3_BUCKET_NAME is not configured or if URL generation fails.
 */
export async function getPresignedUrlForDownload(
  key: string,
): Promise<string> {
  if (!S3_BUCKET_NAME) {
    throw new Error(
      "S3_BUCKET_NAME is not configured in environment variables.",
    );
  }
  const s3Client = getS3Client();
  const command = new GetObjectCommand({
    Bucket: S3_BUCKET_NAME,
    Key: key,
  });

  try {
    const url = await getSignedUrl(s3Client, command, {
      expiresIn: PRESIGNED_URL_EXPIRES_IN,
    });
    console.log(`Generated presigned URL for ${key}.`);
    return url;
  } catch (error) {
    console.error(`Error generating presigned URL for ${key}:`, error);
    if (error instanceof S3ServiceException) {
      throw new Error(
        `S3 Presigned URL Error (${error.name}): ${error.message} - Code: ${error.$metadata.httpStatusCode}`,
      );
    }
    throw new Error(
      `An unexpected error occurred during presigned URL generation: ${(error as Error).message}`,
    );
  }
}
```
Here's what I did and why: This file defines constants and helper functions for ABNT styling in `docx` documents. For now, it includes basic style IDs that are expected to be present in the `protocol-template.docx`. As ABNT requirements are complex, this file will likely grow with more specific style definitions and utility functions for creating styled document elements.
Filepath: src/lib/generators/templates.ts
```ts
/**
 * ABNT Template Configuration and Styling for DOCX Generation.
 *
 * This file defines constants for style IDs expected in the ABNT Word template
 * and may include helper functions for applying these styles.
 */

// These are placeholder style IDs. The actual IDs must match those
// defined in the `public/templates/protocol-template.docx` file.
export const ABNT_STYLE_IDS = {
  // Paragraph Styles
  NORMAL: "NormalWeb", // Default paragraph style, often 'Normal' or 'NormalWeb' in Word
  HEADING_1: "Heading1", // Example style ID for "Título 1"
  HEADING_2: "Heading2", // Example style ID for "Título 2"
  HEADING_3: "Heading3", // Example style ID for "Título 3"
  LIST_BULLET: "ListBullet", // Style for bulleted lists
  LIST_NUMBER: "ListNumber", // Style for numbered lists
  CITATION_LONG: "CitationLong", // Style for long direct quotes (recuadas)
  FOOTNOTE_TEXT: "FootnoteText", // Style for footnote text

  // Character Styles (can be applied to TextRuns)
  STRONG: "Strong", // For bold text, often a default Word style
  EMPHASIS: "Emphasis", // For italic text, often a default Word style
  CITATION_INLINE: "CitationInline", // Custom style for inline citations (e.g., (Autor, ANO))

  // Table Styles
  TABLE_GRID: "TableGrid", // Default grid table style
  TABLE_ABNT_CUSTOM: "TableABNTCustom", // Custom ABNT-compliant table style if defined
};

// ABNT NBR 14724 basic page setup (in twips: 1 inch = 1440 twips)
// 1 cm = 567 twips (approx, Word uses 566.9291338582677)
const CM_TO_TWIPS = 567;
export const ABNT_PAGE_MARGI<ctrl62>g-office;version=1;encoding=UTF-8" standalone="yes"?>
<w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing" xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex" xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid" xmlns:w16="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup" xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk" xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml" xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape" mc:Ignorable="w14 w15 w16cex w16cid w16 wpc wpg wpi wps" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex">
    <w:body>
        <w:p w:rsidR="005F7C39" w:rsidRDefault="005F7C39">
            <w:pPr>
                <w:pStyle w:val="Heading1"/>
            </w:pPr>
            <w:r>
                <w:t>Título 1 (Estilo Heading1)</w:t>
            </w:r>
        </w:p>
        <w:p w:rsidR="005F7C39" w:rsidRDefault="005F7C39">
            <w:pPr>
                <w:pStyle w:val="Heading2"/>
            </w:pPr>
            <w:r>
                <w:t>Título 2 (Estilo Heading2)</w:t>
            </w:r>
        </w:p>
        <w:p w:rsidR="005F7C39" w:rsidRDefault="005F7C39">
            <w:pPr>
                <w:pStyle w:val="NormalWeb"/>
            </w:pPr>
            <w:r>
                <w:t>Este é um parágrafo com o estilo NormalWeb. Ele serve como base para o conteúdo do protocolo.</w:t>
            </w:r>
        </w:p>
        <w:p w:rsidR="005F7C39" w:rsidRDefault="005F7C39">
            <w:pPr>
                <w:pStyle w:val="NormalWeb"/>
            </w:pPr>
        </w:p>
        <w:p w:rsidR="005F7C39" w:rsidRDefault="005F7C39">
            <w:pPr>
                <w:pStyle w:val="ListBullet"/>
            </w:pPr>
            <w:r>
                <w:t>Item de lista com marcador (Estilo ListBullet)</w:t>
            </w:r>
        </w:p>
        <w:p w:rsidR="005F7C39" w:rsidRDefault="005F7C39">
            <w:pPr>
                <w:pStyle w:val="ListNumber"/>
            </w:pPr>
            <w:r>
                <w:t>Item de lista numerada (Estilo ListNumber)</w:t>
            </w:r>
        </w:p>
        <w:sectPr w:rsidR="005F7C39">
            <w:pgSz w:w="11906" w:h="16838"/>
            <w:pgMar w:top="1701" w:right="1134" w:bottom="1134" w:left="1701" w:header="708" w:footer="708" w:gutter="0"/>
            <w:cols w:space="708"/>
            <w:docGrid w:linePitch="360"/>
        </w:sectPr>
    </w:body>
</w:document>
```

Here's what I did and why: This file creates a tRPC router for document export operations. It defines an `exportProtocolDocx` mutation that takes a protocol ID and version ID, fetches the protocol content, generates a DOCX document using `generateProtocolDocx`, uploads it to S3, and returns a presigned URL for download. This provides the API endpoint for clients to request document exports.
Filepath: src/server/api/routers/export.ts
```ts
/**
 * tRPC Router for Document Export operations
 */
import { z } from "zod";
import { TRPCError } from "@trpc/server";
import { router, protectedProcedure } from "../trpc";
import { generateProtocolDocx } from "@/lib/generators/docx";
import { uploadToS3, getPresignedUrlForDownload } from "@/lib/s3/actions";
import type { ProtocolFullContent } from "@/types/protocol";

const ExportInputSchema = z.object({
  protocolId: z.string().uuid("ID de protocolo inválido."),
  versionId: z.string().uuid("ID de versão de protocolo inválido."),
  format: z.enum(["docx"]), // Extend with "pdf", "svg" later
});

export const exportRouter = router({
  exportProtocol: protectedProcedure
    .input(ExportInputSchema)
    .mutation(async ({ ctx, input }) => {
      const { protocolId, versionId, format } = input;

      const protocolVersion = await ctx.db.protocolVersion.findUnique({
        where: { id: versionId, protocolId: protocolId },
        include: { Protocol: true },
      });

      if (!protocolVersion) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: `Versão de protocolo com ID '${versionId}' para o protocolo '${protocolId}' não encontrada.`,
        });
      }

      const protocolContent =
        protocolVersion.content as unknown as ProtocolFullContent;
      const protocolTitle = protocolVersion.Protocol.title || "protocolo";
      const protocolCode = protocolVersion.Protocol.code || "PROTO";
      const versionNum = protocolVersion.versionNumber;

      // Sanitize title for use in filename
      const safeTitle = protocolTitle
        .replace(/[^a-z0-9\s-]/gi, "")
        .replace(/\s+/g, "_")
        .toLowerCase();
      const filename = `${protocolCode}_v${versionNum}_${safeTitle}.${format}`;
      const s3Key = `exports/protocols/${protocolId}/${versionId}/${filename}`;

      let documentBuffer: Buffer;
      let contentType: string;

      switch (format) {
        case "docx":
          documentBuffer = await generateProtocolDocx(protocolContent);
          contentType =
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
          break;
        // Add cases for PDF, SVG later
        default:
          throw new TRPCError({
            code: "BAD_REQUEST",
            message: `Formato de exportação '${format}' não suportado.`,
          });
      }

      try {
        // Upload to S3
        await uploadToS3(s3Key, documentBuffer, contentType);

        // Get presigned URL for download
        const downloadUrl = await getPresignedUrlForDownload(s3Key);

        return {
          filename,
          url: downloadUrl,
          message: `Documento ${format.toUpperCase()} gerado e pronto para download.`,
        };
      } catch (error) {
        console.error("Error during document export process:", error);
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: `Falha ao exportar o documento: ${(error as Error).message}`,
          cause: error,
        });
      }
    }),
});
```

Here's what I did and why: This file adds the new `exportRouter` to the main application router (`appRouter`). This makes the document export endpoints (defined in `src/server/api/routers/export.ts`) accessible via the tRPC API.
Filepath: src/server/api/root.ts
```ts
/**
 * Root tRPC Router
 *
 * This is the main tRPC router for the application.
 * It merges all other sub-routers (e.g., for protocols, users, AI).
 */
import { router, publicProcedure } from "./trpc";
import { protocolRouter } from "./routers/protocol";
import { userRouter } from "./routers/user";
import { researchRouter } from "./routers/research";
import { generationRouter } from "./routers/generation";
import { exportRouter } from "./routers/export"; // Import the new export router

export const appRouter = router({
  protocol: protocolRouter,
  user: userRouter,
  research: researchRouter,
  generation: generationRouter,
  export: exportRouter, // Add the export router

  // Example health check endpoint (can be kept or removed)
  healthCheck: publicProcedure.query(({ ctx }) => {
    return {
      status: "ok",
      timestamp: new Date().toISOString(),
      isAuthenticated: !!ctx.session?.user,
    };
  }),
});

// Export type definition of API
export type AppRouter = typeof appRouter;

```
Here's what I did and why: The `package.json` file is updated to include `@aws-sdk/client-s3` and `@aws-sdk/s3-request-presigner` as dependencies. These packages are necessary for interacting with AWS S3 to store generated documents and provide secure download links.
Filepath: package.json
```json
{
  "name": "medical-protocol-assistant",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint --fix",
    "format": "prettier --write \"**/*.{js,jsx,ts,tsx,json,css,scss,md,html}\"",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "prepare": "husky install",
    "prisma:migrate:dev": "prisma migrate dev",
    "prisma:generate": "prisma generate",
    "prisma:studio": "prisma studio",
    "prisma:seed": "tsx src/lib/db/seed.ts"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.583.0",
    "@aws-sdk/s3-request-presigner": "^3.583.0",
    "@hookform/resolvers": "^3.3.0",
    "@prisma/client": "^5.14.0",
    "@radix-ui/react-dialog": "latest",
    "@radix-ui/react-dropdown-menu": "latest",
    "@radix-ui/react-label": "latest",
    "@radix-ui/react-popover": "latest",
    "@radix-ui/react-select": "latest",
    "@radix-ui/react-slot": "latest",
    "@radix-ui/react-tooltip": "latest",
    "@react-pdf/renderer": "^3.4.0",
    "@tanstack/react-query": "^5.0.0",
    "@trpc/client": "^11.1.2",
    "@trpc/react-query": "^11.1.2",
    "@trpc/server": "^11.1.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "date-fns": "^3.6.0",
    "docx": "^8.5.0",
    "lucide-react": "latest",
    "mermaid": "^10.9.0",
    "next": "^14.2.0",
    "next-auth": "^4.24.0",
    "openai": "^4.47.0",
    "papaparse": "^5.4.0",
    "react": "^18.3.0",
    "react-dom": "^18.3.0",
    "react-hook-form": "^7.51.0",
    "reactflow": "^11.11.0",
    "superjson": "^2.2.1",
    "tailwind-merge": "^2.2.0",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.1.0",
    "zod": "^3.23.0",
    "zustand": "^4.5.0"
  },
  "devDependencies": {
    "@tanstack/react-query-devtools": "^5.0.0",
    "@types/node": "^20.12.2",
    "@types/papaparse": "^5.3.14",
    "@types/react": "^18.2.73",
    "@types/react-dom": "^18.2.25",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "@typescript-eslint/parser": "^7.0.0",
    "@vitest/ui": "^3.1.4",
    "autoprefixer": "^10.4.19",
    "eslint": "^8.57.0",
    "eslint-config-next": "^14.2.0",
    "eslint-config-prettier": "^9.1.0",
    "eslint-plugin-prettier": "^5.1.3",
    "husky": "^9.0.11",
    "lint-staged": "^15.2.2",
    "postcss": "^8.4.38",
    "prettier": "^3.2.5",
    "prettier-plugin-tailwindcss": "^0.5.14",
    "prisma": "^5.14.0",
    "tailwindcss": "^3.4.0",
    "tsx": "^4.7.1",
    "typescript": "^5.4.0",
    "vitest": "^3.1.4"
  },
  "prisma": {
    "seed": "tsx src/lib/db/seed.ts"
  }
}
```
Here's what I did and why: Updated `.env.example` to include placeholders for AWS S3 configuration: `AWS_REGION`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `S3_BUCKET_NAME`. These are necessary for the S3 client to connect and for storing/retrieving exported documents.
Filepath: .env.example
```env
# PostgreSQL Database Connection URL
# Example: postgresql://user:password@host:port/database
DATABASE_URL="postgresql://postgres:password@localhost:5432/medical_protocols"

# NextAuth Configuration
# Generate a secret with `openssl rand -base64 32`
NEXTAUTH_SECRET="YOUR_NEXTAUTH_SECRET"
NEXTAUTH_URL="http://localhost:3000" # Change for production

# OpenAI API Key
OPENAI_API_KEY="sk-YOUR_OPENAI_API_KEY"
OPENAI_ORG_ID="" # Optional: Your OpenAI Organization ID

# DeepResearch API Key (if applicable)
DEEPRESEARCH_API_KEY=""

# Application Configuration
# LOG_LEVEL can be: 'fatal', 'error', 'warn', 'info', 'debug', 'trace' or 'silent'.
LOG_LEVEL="info"

# AWS S3 Bucket (for document storage)
AWS_REGION="your-s3-bucket-region" # e.g., us-east-1
AWS_ACCESS_KEY_ID="YOUR_AWS_ACCESS_KEY_ID"
AWS_SECRET_ACCESS_KEY="YOUR_AWS_SECRET_ACCESS_KEY"
S3_BUCKET_NAME="your-s3-bucket-name-for-protocols"
```

STEP 13 COMPLETE

**Summary**
- Implemented DOCX generation foundation, S3 client setup, S3 upload/presigned URL actions, and a tRPC export router.

**Commit Message**
feat(export): implement DOCX generation and S3 export

This commit introduces the capability to generate DOCX documents from protocol content and export them via S3.

- Added `docx` library logic for basic protocol document structure.
- Created `src/lib/generators/docx.ts` for DOCX generation.
- Added `src/lib/generators/templates.ts` for ABNT style constants.
- Included a placeholder `public/templates/protocol-template.docx`.
- Implemented S3 client (`src/lib/s3/client.ts`) and S3 actions (`src/lib/s3/actions.ts`) for uploading files and generating presigned download URLs.
- Created `src/server/api/routers/export.ts` tRPC router for document export.
- Updated `package.json` with AWS SDK dependencies.
- Updated `.env.example` with S3 configuration variables.

**Changed Files**
- src/lib/s3/client.ts
- src/lib/s3/actions.ts
- src/lib/generators/templates.ts
- src/lib/generators/docx.ts
- public/templates/protocol-template.docx
- src/server/api/routers/export.ts
- src/server/api/root.ts (modified)
- package.json (modified)
- .env.example (modified)

**USER INSTRUCTIONS**
1.  Install the new AWS SDK dependencies:
    ```bash
    pnpm install
    ```
2.  Update your `.env.local` file with AWS S3 credentials and bucket information:
    ```
    AWS_REGION="your-s3-bucket-region"
    AWS_ACCESS_KEY_ID="YOUR_AWS_ACCESS_KEY_ID"
    AWS_SECRET_ACCESS_KEY="YOUR_AWS_SECRET_ACCESS_KEY"
    S3_BUCKET_NAME="your-s3-bucket-name-for-protocols"
    ```
3.  Create an ABNT-compliant Word template named `protocol-template.docx` and place it in the `public/templates/` directory. The current implementation expects basic styles like `Heading1`, `Heading2`, `NormalWeb`, `ListBullet`, `ListNumber` to be defined in this template. For complex ABNT formatting, these styles must be meticulously set up in the Word template.
4.  Ensure your S3 bucket is created and has appropriate CORS configuration if you plan to download directly from the browser using the presigned URL, and that the IAM user associated with the credentials has `PutObject` and `GetObject` permissions for the bucket.

```